// @flow
/* eslint-disable no-use-before-define */
/**
 * On Chain Dapps - REST API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSBidDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSBidDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSBidDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    tokens_bid?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSBidDTO
     */
    bidder?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    buyer_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDTO
     */
    seller_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSCollectionDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    royalty_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_min_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_max_sale_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSCollectionDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSDataSourcesDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    block_range?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    causality_region?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    manifest_idx?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    parent?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    context?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSDataSourcesDTO
     */
    done_at?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSItemDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSItemDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSItemDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSItemDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketPlaceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    schema_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    subgraph_version?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    methodology_version?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketPlaceDTO
     */
    cumulative_unique_traders?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSMarketplaceDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    collection_count?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_trade_volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    marketplace_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    creator_revenue_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    total_revenue_eth?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    trade_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    cumulative_unique_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_active_traders?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_collection_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSMarketplaceDailySnapshotDTO
     */
    daily_traded_item_count?: number;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    recv_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_number?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    transaction_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    log_index?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    is_bundle?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    collection?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    token_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    price_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSTradeDTO
     */
    seller?: string;
}

/**
 * 
 * @export
 */
export type CRYPTOPUNKSUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CRYPTOPUNKSUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof CRYPTOPUNKSUserDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    block_range?: string;
    /**
     * 
     * @type {string}
     * @memberof CRYPTOPUNKSUserDTO
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type CowOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowOrderDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    owner?: string;
    /**
     * Block\'s timestamp on trade event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    trades_timestamp?: string;
    /**
     * Block\'s timestamp on invalidate event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    invalidate_timestamp?: string;
    /**
     * Block\'s timestamp on presign event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    presign_timestamp?: string;
    /**
     * Determines whether order is signed.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_signed?: boolean;
    /**
     * Determines whether order is valid.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_valid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowOrderDTO
     */
    vid?: number;
}

/**
 * A settlement comprises a list of traded tokens with their corresponding price in the batch.
 * @export
 */
export type CowSettlementDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowSettlementDTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    id?: string;
    /**
     * Solver\'s address.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    solver?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    tx_hash?: string;
    /**
     * First trade timestamp.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    first_trade_timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CowSettlementDTO
     */
    vid?: number;
}

/**
 * Stores information for a specific token across all pairs that token is included in.
 * @export
 */
export type CowTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTokenDTO
     */
    block_number?: number;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    id?: string;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    address?: string;
    /**
     * First token trade block timestamp.
     * @type {string}
     * @memberof CowTokenDTO
     */
    first_trade_timestamp?: string;
    /**
     * Token name fetched by ERC20 contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    name?: string;
    /**
     * Token symbol fetched by contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    symbol?: string;
    /**
     * Token decimals fetched by contract call.
     * @type {number}
     * @memberof CowTokenDTO
     */
    decimals?: number;
    /**
     * Sum of total amount traded for this token.
     * @type {string}
     * @memberof CowTokenDTO
     */
    total_volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade entity.
 * @export
 */
export type CowTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTradeDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (order id)|(transaction hash)|(event index).
     * @type {string}
     * @memberof CowTradeDTO
     */
    id?: string;
    /**
     * Block\'s timestamp.
     * @type {string}
     * @memberof CowTradeDTO
     */
    timestamp?: string;
    /**
     * Transaction\'s gas price.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_price?: string;
    /**
     * Transaction\'s gas limit.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_limit?: string;
    /**
     * Trade\'s fee amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    fee_amount?: string;
    /**
     * Trade event transaction hash.
     * @type {string}
     * @memberof CowTradeDTO
     */
    tx_hash?: string;
    /**
     * Reference to settlement.
     * @type {string}
     * @memberof CowTradeDTO
     */
    settlement?: string;
    /**
     * Buy amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_amount?: string;
    /**
     * Sell amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_amount?: string;
    /**
     * Address of token that is sold.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_token?: string;
    /**
     * Address of token that is bought.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_token?: string;
    /**
     * Reference to order.
     * @type {string}
     * @memberof CowTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CowTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type CowUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowUserDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    address?: string;
    /**
     * First trade block timestamp.
     * @type {string}
     * @memberof CowUserDTO
     */
    first_trade_timestamp?: string;
    /**
     * Determines if user has solved a settlement.
     * @type {boolean}
     * @memberof CowUserDTO
     */
    is_solver?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAccountDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAddLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAdminFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAmplificationCoeffChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool_id)-(coin_index).
     * @type {string}
     * @memberof CurveCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    underlying?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    balance?: string;
    /**
     * Exchange rate between this coin and the associated underlying coin within the pool.
     * @type {string}
     * @memberof CurveCoinDTO
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveCoinDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveContractDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    id?: string;
    /**
     * Human-readable description.
     * @type {string}
     * @memberof CurveContractDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveContractVersionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    contract?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveDailyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveExchangeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    receiver?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CurveExchangeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction_id?: string;
}

/**
 * 
 * @export
 */
export type CurveFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveGaugeLiquidityDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTotalWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveHourlyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveLpTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    pool?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurvePoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurvePoolDTO
     */
    block_number?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    id?: string;
    /**
     * Pool\'s human-readable name.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    name?: string;
    /**
     * Identify whether pool is a metapool.
     * @type {boolean}
     * @memberof CurvePoolDTO
     */
    is_meta?: boolean;
    /**
     * Registry contract address from where this pool was registered.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    registry_address?: string;
    /**
     * Swap contract address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    swap_address?: string;
    /**
     * Address of the token representing LP share.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    lp_token?: string;
    /**
     * Number of coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    coin_count?: string;
    /**
     * Number of underlying coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    underlying_count?: string;
    /**
     * Amplification coefficient multiplied by n * (n - 1).
     * @type {string}
     * @memberof CurvePoolDTO
     */
    a?: string;
    /**
     * Fee to charge for exchanges.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    fee?: string;
    /**
     * Admin fee is represented as a percentage of the total fee collected on a swap.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    admin_fee?: string;
    /**
     * Admin address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    owner?: string;
    /**
     * Average dollar value of pool token.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    virtual_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    locked?: string;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    added_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    exchange_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    id?: string;
    /**
     * Sequential number in related to the realted voting app.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    _number?: string;
    /**
     * Voting app instance.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    app?: string;
    /**
     * Proposal creator\'s account.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    creator?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    execution_script?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    expire_date?: string;
    /**
     * Percentage of positive votes in total possible votes for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    minimum_quorum?: string;
    /**
     * Percentage of positive votes needed for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    required_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    snapshot_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    voting_power?: string;
    /**
     * Link to metadata file.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    metadata?: string;
    /**
     * Proposal description text.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    text?: string;
    /**
     * Number of votes received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    vote_count?: string;
    /**
     * Number of positive votes (yes) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    positive_vote_count?: string;
    /**
     * Number of negative votes (no) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    negative_vote_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_quorum?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    staked_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    total_staked?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    proposal?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CurveProposalVoteDTO
     */
    supports?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    stake?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityOneEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    token_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    coin_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveSystemStateDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    block_number?: number;
    /**
     * Singleton ID, equals to \'current\'.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    id?: string;
    /**
     * Current pool registry address.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    registry_contract?: string;
    /**
     * Number of contracts in the AddressProvider registry.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    contract_count?: string;
    /**
     * Number of gauges registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_count?: string;
    /**
     * Number of gauge types registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_type_count?: string;
    /**
     * Number of active pools.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    pool_count?: string;
    /**
     * Number of tokens registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    token_count?: string;
    /**
     * Total number of pools (including removed ones).
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    total_pool_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveTokenDTO
     */
    pools?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CurveTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type CurveTransferOwnershipEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    new_admin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveUnderlyingCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    block_number?: number;
    /**
     * Equals to: (pool_id)-(coin_index).
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    coin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveVotingAppDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    block_number?: number;
    /**
     * App address.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    codename?: string;
    /**
     * Minimum balance needed to create a proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_balance?: string;
    /**
     * Percentage of positive votes in total possible votes for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_quorum?: string;
    /**
     * Minimum time needed to pass between user\'s previous proposal and a user creating a new proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_time?: string;
    /**
     * Percentage of positive votes needed for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    required_support?: string;
    /**
     * Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision).
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_time?: string;
    /**
     * Number of proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    proposal_count?: string;
    /**
     * Number of votes received by all the proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_count?: string;
    /**
     * Address of the token used for voting.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveWeeklyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    vid?: number;
}

/**
 * Batch executed. Every batch will contain at least solution with the a set of trades that are executed in it
 * @export
 */
export type DexBatchDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexBatchDTO
     */
    block_number?: number;
    /**
     * Identifier.
     * @type {string}
     * @memberof DexBatchDTO
     */
    id?: string;
    /**
     * Start epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    start_epoch?: string;
    /**
     * End epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    end_epoch?: string;
    /**
     * Reference to solution.
     * @type {string}
     * @memberof DexBatchDTO
     */
    solution?: string;
    /**
     * First solution epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    first_solution_epoch?: string;
    /**
     * Last revert epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    last_revert_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexBatchDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexBatchDTO
     */
    vid?: number;
}

/**
 * Deposit of an user.
 * @export
 */
export type DexDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexDepositDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(token id).
     * @type {string}
     * @memberof DexDepositDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    user?: string;
    /**
     * Token address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    token_address?: string;
    /**
     * Amount of deposit.
     * @type {string}
     * @memberof DexDepositDTO
     */
    amount?: string;
    /**
     * Identifier (numerical).
     * @type {string}
     * @memberof DexDepositDTO
     */
    batch_id?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexDepositDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexDepositDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexDepositDTO
     */
    vid?: number;
}

/**
 * Order submitted by an user. It has a validity (dates) so they can only be executed from/until some given batches. Partial executions of this trades must respect the limit price.
 * @export
 */
export type DexOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexOrderDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (owner address)-(order id)
     * @type {string}
     * @memberof DexOrderDTO
     */
    id?: string;
    /**
     * Reference to owner.
     * @type {string}
     * @memberof DexOrderDTO
     */
    owner?: string;
    /**
     * Order id.
     * @type {number}
     * @memberof DexOrderDTO
     */
    order_id?: number;
    /**
     * Batch id from which order became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_batch_id?: string;
    /**
     * Start of epoch in which order was placed and became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_epoch?: string;
    /**
     * Batch id until which trade was still valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_batch_id?: string;
    /**
     * End of epoch in which order was placed.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_epoch?: string;
    /**
     * Identifier of token that was bought.
     * @type {string}
     * @memberof DexOrderDTO
     */
    buy_token?: string;
    /**
     * Identifier of token that was sold.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sell_token?: string;
    /**
     * Price enumerator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_numerator?: string;
    /**
     * Price denominator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_denominator?: string;
    /**
     * Maximum sell amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    max_sell_amount?: string;
    /**
     * Minimum receive amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    min_receive_amount?: string;
    /**
     * Sold volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sold_volume?: string;
    /**
     * Bought volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    bought_volume?: string;
    /**
     * Epoch in which order was created.
     * @type {string}
     * @memberof DexOrderDTO
     */
    create_epoch?: string;
    /**
     * Epoch in which order was cancelled.
     * @type {string}
     * @memberof DexOrderDTO
     */
    cancel_epoch?: string;
    /**
     * Epoch in which order was deleted.
     * @type {string}
     * @memberof DexOrderDTO
     */
    delete_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_hash?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexOrderDTO
     */
    vid?: number;
}

/**
 * Token price in conjuction with batch id.
 * @export
 */
export type DexPriceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexPriceDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (token id)-(batch id).
     * @type {string}
     * @memberof DexPriceDTO
     */
    id?: string;
    /**
     * Token identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    token?: string;
    /**
     * Batch identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    batch_id?: string;
    /**
     * Price enumerator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_numerator?: string;
    /**
     * Price denominator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_denominator?: string;
    /**
     * Volume.
     * @type {string}
     * @memberof DexPriceDTO
     */
    volume?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexPriceDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexPriceDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexPriceDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type DexSolutionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexSolutionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    batch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    solver?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    fee_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    objective_value?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    utility?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DexSolutionDTO
     */
    trades?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexSolutionDTO
     */
    vid?: number;
}

/**
 * A type collecting global stats about this instance of Gnosis Protocol.
 * @export
 */
export type DexStatsDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexStatsDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexStatsDTO
     */
    id?: string;
    /**
     * The total volume denominated in OWL (all sell amounts combined).
     * @type {string}
     * @memberof DexStatsDTO
     */
    volume_in_owl?: string;
    /**
     * The total trader surplus in OWL.
     * @type {string}
     * @memberof DexStatsDTO
     */
    utility_in_owl?: string;
    /**
     * The total amount of OWL burnt (equivalent to fees rewarded to solvers).
     * @type {string}
     * @memberof DexStatsDTO
     */
    owl_burnt?: string;
    /**
     * The total number of settled batches.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_batch_count?: number;
    /**
     * The total number of settled trades.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_trade_count?: number;
    /**
     * The number of listed tokens.
     * @type {number}
     * @memberof DexStatsDTO
     */
    listed_tokens?: number;
    /**
     * 
     * @type {number}
     * @memberof DexStatsDTO
     */
    vid?: number;
}

/**
 * Registered token.
 * @export
 */
export type DexTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    name?: string;
    /**
     * Cumulative sell volume.
     * @type {string}
     * @memberof DexTokenDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade for a single user, as part of a ring trade. It\'s part of the solution submitted by a solver for a given batch.
 * @export
 */
export type DexTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTradeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_batch_id?: string;
    /**
     * The date of the end of the batch.
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_token?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_token?: string;
    /**
     * The date where the transaction was mined.
     * @type {string}
     * @memberof DexTradeDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof DexTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * User of the protocol. Any ethereum account that deposited tokens or traded.
 * @export
 */
export type DexUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexUserDTO
     */
    vid?: number;
}

/**
 * Withdraw of an user.
 * @export
 */
export type DexWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(id).
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    vid?: number;
}

/**
 * Withdraw request of an user
 * @export
 */
export type DexWithdrawRequestDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(id).
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    withdrawable_from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type NumericsBigInteger = {
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_power_of_two?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_zero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_one?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_even?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NumericsBigInteger
     */
    sign?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD.
 * @export
 */
export type SushiswapBundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    block_number?: number;
    /**
     * Hardcoded to \'1\'.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    id?: string;
    /**
     * Price of native.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type SushiswapBurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction id):(transaction.burns.length).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    log_index?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SushiswapBurnDTO
     */
    complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type SushiswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    _date?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    factory?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    untracked_volume?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type SushiswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Sushiswap factory.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    pair_count?: string;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    tx_count?: string;
    /**
     * Total count of tokens.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    token_count?: string;
    /**
     * Users count.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    user_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    block_number?: number;
    /**
     * Start of hour timestamp.
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    _date?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    factory?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    untracked_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapLiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    user?: string;
    /**
     * Pair address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * Block number at which position was created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block?: number;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type SushiswapLiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)-(timestamp)
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Block in which snapshot has been created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type SushiswapMintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (transaction hash)-(index in the transaction mint array).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    vid?: number;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type SushiswapPairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    block_number?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    id?: string;
    /**
     * Factory contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    factory?: string;
    /**
     * Friendly name, format: (token0 name)-(token1 name)
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    name?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    untracked_volume_usd?: string;
    /**
     * All time amount of transactions on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tx_count?: string;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    liquidity_provider_count?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    timestamp?: string;
    /**
     * Block number in which pair information was created in.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    block?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type SushiswapPairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair id)-(day start timestamp).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    pair?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type SushiswapPairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair id)-(hour start timestamp).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    id?: string;
    /**
     * Hour start timestamp.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type SushiswapSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    sender?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    to?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    log_index?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof SushiswapSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type SushiswapTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    block_number?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    id?: string;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    factory?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    decimals?: string;
    /**
     * Total supply of liquidity token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    total_supply?: string;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Amount of transactions all time in pairs including token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    tx_count?: string;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    derived_eth?: string;
    /**
     * Array of whitelisted pairs.
     * @type {Array<string>}
     * @memberof SushiswapTokenDTO
     */
    whitelist_pairs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type SushiswapTokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, day start timestamp in unix / 86400.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    tx_count?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type SushiswapTransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapUserDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    block_range?: string;
    /**
     * Account address.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    id?: string;
    /**
     * Number of positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    position_count?: number;
    /**
     * Number of open positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions this account has.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    closed_position_count?: number;
    /**
     * Number of deposits this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals this account made.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    withdraw_count?: number;
    /**
     * Number of times this account has traded/swapped.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMAccountDTO
     */
    swap_count?: number;
}

/**
 * Entity for calculating daily/hourly active users.
 * @export
 */
export type UNISWAPV3ETHEREUMActiveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (daily/hourly)-(address of the account)-(days/hours since unix epoch)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMActiveAccountDTO
     */
    block_range?: string;
}

/**
 * Entity represents a user action in the protocol involving the addition of funds to a liquidity pool.
 * @export
 */
export type UNISWAPV3ETHEREUMDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_?: number;
    /**
     * Identifier, format: (transaction hash)-(log index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    account?: string;
    /**
     * The user position changed by this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    position?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    pool?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    tick_upper?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDepositDTO
     */
    block_range?: string;
}

/**
 *  Decentralized exchange (Dex) automated market maker (Amm) protocol. It\'s an entity that represents a protocol involving a smart contract that use automated market makers.
 * @export
 */
export type UNISWAPV3ETHEREUMDexAmmProtocolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the protocol\'s main contract (Factory, Registry, etc).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    id?: string;
    /**
     * Name of the protocol, including version. e.g. Uniswap v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    name?: string;
    /**
     * Slug of protocol, including version. e.g. uniswap-v3.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    slug?: string;
    /**
     * Version of the subgraph schema, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    schema_version?: string;
    /**
     * Version of the subgraph implementation, in SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    subgraph_version?: string;
    /**
     * Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    methodology_version?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All historical volume in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushis 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Number of cumulative unique users.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_users?: number;
    /**
     * Number of cumulative liquidity providers.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_l_ps?: number;
    /**
     * Number of cumulative traders
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_unique_traders?: number;
    /**
     * Total number of pools.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    total_pool_count?: number;
    /**
     * Total number of open positions.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    open_position_count?: number;
    /**
     * Total number of positions (open and closed).
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    cumulative_position_count?: number;
    /**
     * Day ID of the most recent daily snapshot.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    last_update_block_number?: string;
    /**
     * This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis.
     * @type {boolean}
     * @memberof UNISWAPV3ETHEREUMDexAmmProtocolDTO
     */
    regenesis?: boolean;
}

/**
 * Daily financial metrics for Uniswap V3.
 * @export
 */
export type UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Block number of when this snapshot was taken/last modified.)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Current TVL (Total Value Locked) of the entire protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_protocol_side_value_usd?: string;
    /**
     * All supply-side value locking in USD that remains uncollected and unused in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    uncollected_supply_side_value_usd?: string;
    /**
     * Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    protocol_controlled_value_usd?: string;
    /**
     * All trade volume occurred in a given day, in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_volume_usd?: string;
    /**
     * All historical trade volume in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_supply_side_revenue_usd?: string;
    /**
     * Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushis 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_protocol_side_revenue_usd?: string;
    /**
     * Gross revenue for the protocol (revenue claimed by the protocol). Examples: AMM protocol fee (Sushis 0.05%). OpenSea 10% sell fee.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    daily_total_revenue_usd?: string;
    /**
     * All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after the interval has passed).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolAmountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    id?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    input_token_balances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolAmountDTO
     */
    token_prices?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolFeeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    block_range?: string;
    /**
     * Identifier, format: (fee type)-(pool address)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    id?: string;
    /**
     * Fee as a percentage of the trade (swap) amount. Does not always apply 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolFeeDTO
     */
    fee_percentage?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (Smart contract address of the pool)-( # of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hour?: number;
    /**
     * The protocol this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * The pool this snapshot belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    pool?: string;
    /**
     * Current tick representing the price of token0/token1
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    tick?: string;
    /**
     * Current TVL (Total Value Locked) of this pool
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_value_locked_usd?: string;
    /**
     * The sum of all active and non-active liquidity for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity?: string;
    /**
     * The sum of all active and non-active liquidity in USD for this pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    total_liquidity_usd?: string;
    /**
     * All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity?: string;
    /**
     * All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pool\'s current tick.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    active_liquidity_usd?: string;
    /**
     * All protocol-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_token_amounts?: Array<string>;
    /**
     * All protocol-side value locking in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_protocol_side_values_usd?: Array<string>;
    /**
     * All supply-side value locked in token amounts that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_token_amounts?: Array<string>;
    /**
     * All supply-side value locked in USD that remains uncollected and unused in the pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    uncollected_supply_side_values_usd?: Array<string>;
    /**
     * All revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_supply_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the supply side.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_supply_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_protocol_side_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool, accrued to the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_protocol_side_revenue_usd?: string;
    /**
     * All revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_total_revenue_usd?: string;
    /**
     * Hourly revenue generated by the liquidity pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_total_revenue_usd?: string;
    /**
     * All historical trade volume occurred in this pool, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_usd?: string;
    /**
     * All trade volume occurred in a given hour, in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_usd?: string;
    /**
     * All trade volume, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_amount?: Array<string>;
    /**
     * All trade volume, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_volume_by_token_usd?: Array<string>;
    /**
     * All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_volume_by_token_usd?: Array<string>;
    /**
     * Amount of input tokens in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances?: Array<string>;
    /**
     * Amount of input tokens in USD in the pool. The ordering should be the same as the pool\'s `inputTokens` field.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_balances_usd?: Array<string>;
    /**
     * Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    input_token_weights?: Array<string>;
    /**
     * Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    staked_output_token_amount?: string;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in token\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_amount?: Array<string>;
    /**
     * Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    reward_token_emissions_usd?: Array<string>;
    /**
     * Total number of deposits (add liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_deposit_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_withdraw_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps)
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    cumulative_swap_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Number of positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    position_count?: number;
    /**
     * Number of open positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    open_position_count?: number;
    /**
     * Number of closed positions in this market
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    closed_position_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    vid?: number;
    /**
     * (account address)-(market address)-(count)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    id?: string;
    /**
     * Account that owns this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    account?: string;
    /**
     * The liquidity pool in which this position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    pool?: string;
    /**
     * The hash of the transaction that opened this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_opened?: string;
    /**
     * The hash of the transaction that closed this position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    hash_closed?: string;
    /**
     * Block number of when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_opened?: string;
    /**
     * Timestamp when the position was opened
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_opened?: string;
    /**
     * Block number of when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    block_number_closed?: string;
    /**
     * Timestamp when the position was closed (0 if still open)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    timestamp_closed?: string;
    /**
     * lower tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_lower?: string;
    /**
     * upper tick of the position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    tick_upper?: string;
    /**
     * Token that is to represent ownership of liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionDTO
     */
    withdraw_count?: number;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    block_number?: number;
    /**
     *  (position id )-( transaction hash )-( log index ) 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    hash?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    log_index?: number;
    /**
     * Nonce of the transaction that triggered this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    nonce?: string;
    /**
     * Position of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    position?: string;
    /**
     * Type of token used to track liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_token_type?: string;
    /**
     * total position liquidity
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * total position liquidity in USD
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    liquidity_usd?: string;
    /**
     * amount of tokens ever deposited to position
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD deposited to position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_deposit_usd?: string;
    /**
     * amount of tokens ever withdrawn from position (without fees)
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_token_amounts?: Array<string>;
    /**
     * amount of tokens in USD withdrawn from position (without fees)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_withdraw_usd?: string;
    /**
     * Total reward token accumulated under this position, in native amounts
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_token_amounts?: Array<string>;
    /**
     * Total reward token accumulated under this position, in USD
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    cumulative_reward_usd?: Array<string>;
    /**
     * Number of deposits related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    deposit_count?: number;
    /**
     * Number of withdrawals related to this position
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    withdraw_count?: number;
    /**
     * Timestamp of this snapshot
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMPositionSnapshotDTO
     */
    timestamp?: string;
}

/**
 * Reward tokens awarded to lenders and borrowers.
 * @export
 */
export type UNISWAPV3ETHEREUMRewardTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    block_number?: number;
    /**
     * (reward token type)-(smart contract address of the reward token)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    id?: string;
    /**
     * Reference to the actual token
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMRewardTokenDTO
     */
    token?: string;
}

/**
 * Trade (swap) event occurred in a pool.
 * @export
 */
export type UNISWAPV3ETHEREUMSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_number?: number;
    /**
     * Block number in which the swap operation was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    block_?: number;
    /**
     * Unique string identifier of the swap operation, format: (transaction hash)-(log index).
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    account?: string;
    /**
     * The pool involving this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool?: string;
    /**
     * Timestamp of this event.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    timestamp?: string;
    /**
     * Tick of the swap operation.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    tick?: string;
    /**
     * Token deposited into pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_in?: string;
    /**
     * Amount of token deposited into pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in?: string;
    /**
     * Amount of token deposited into pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_in_usd?: string;
    /**
     * Token withdrawn from pool.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    token_out?: string;
    /**
     * Amount of token withdrawn from pool in native units.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out?: string;
    /**
     * Amount of token withdrawn from pool in USD.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    amount_out_usd?: string;
    /**
     * Amount of input tokens in the liquidity pool.
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UNISWAPV3ETHEREUMSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    vid?: number;
    /**
     * (pool address)-(tick index)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    id?: string;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    index?: string;
    /**
     * Liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    pool?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_timestamp?: string;
    /**
     * Creation block number
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    created_block_number?: string;
    /**
     * calculated price of token0 of tick within this pool - constant
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    prices?: Array<string>;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    liquidity_net_usd?: string;
    /**
     * Day ID of the most recent daily snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_day_id?: number;
    /**
     * Hour ID of the most recent hourly snapshot
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_snapshot_hour_id?: number;
    /**
     * Timestamp of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_timestamp?: string;
    /**
     * Block number of the last time this entity was updated
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDTO
     */
    last_update_block_number?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    vid?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(day ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    day_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTickHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    vid?: number;
    /**
     * (pool address)-(tick index)-(hour ID)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    hour_id?: number;
    /**
     * tick index
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    tick?: string;
    /**
     * liquidity pool this tick belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    pool?: string;
    /**
     * total liquidity pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross?: string;
    /**
     * total liquidity in USD pool has as tick lower or upper
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_gross_usd?: string;
    /**
     * how much liquidity changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net?: string;
    /**
     * how much liquidity in USD changes when tick crossed
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    liquidity_net_usd?: string;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTickHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UNISWAPV3ETHEREUMTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_number?: number;
    /**
     * .
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    block_range?: string;
    /**
     * Smart contract address of the token.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    id?: string;
    /**
     * Name of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    name?: string;
    /**
     * Symbol of the token, mirrored from the smart contract.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    symbol?: string;
    /**
     * The number of decimal places this token uses, default to 18.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    decimals?: number;
    /**
     * Optional field to track the price of a token, mostly for caching purposes.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_usd?: string;
    /**
     * Optional field to track the block number of the last token price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_block_number?: string;
    /**
     * Last pool that gave this token a price.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    last_price_pool?: string;
    /**
     * Amount of tokens in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_supply?: string;
    /**
     * Total value locked in the protocol.
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * The buffer for detecting large price changes.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_price_change_buffer?: number;
    /**
     * The buffer for detecting large TVL (Total Value Locked) impact.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    large_tvl_impact_buffer?: number;
    /**
     * 
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    block_number?: number;
    /**
     * Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    id?: string;
    /**
     * pools token is in that are white listed for USD pricing
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListDTO
     */
    whitelist_pools?: Array<string>;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    block_number?: number;
    /**
     * Whitelist Token Symbol
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    id?: string;
    /**
     * Whitelist Token Address
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO
     */
    address?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    block_number?: number;
    /**
     * ID is # of days since Unix epoch time
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    id?: string;
    /**
     * Number of days since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    day?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique daily active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_transaction_count?: number;
    /**
     * Total number of pools
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    total_pool_count?: number;
    /**
     * Total number of deposits (add liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an day
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    daily_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    block_number?: number;
    /**
     * (# of hours since Unix epoch time)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    id?: string;
    /**
     * Number of hours since Unix epoch time
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hour?: number;
    /**
     * Protocol this snapshot is associated with
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    protocol?: string;
    /**
     * Number of unique hourly active users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_active_users?: number;
    /**
     * Number of cumulative unique users
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    cumulative_unique_users?: number;
    /**
     * Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_transaction_count?: number;
    /**
     * Total number of deposits (add liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_deposit_count?: number;
    /**
     * Total number of withdrawals (remove liquidity) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_withdraw_count?: number;
    /**
     * Total number of trades (swaps) in an hour
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    hourly_swap_count?: number;
    /**
     * Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO
     */
    timestamp?: string;
}

/**
 * 
 * @export
 */
export type UNISWAPV3ETHEREUMWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    block_number?: number;
    /**
     * (transaction hash)-{ Log index }
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    id?: string;
    /**
     * Transaction hash of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    hash?: string;
    /**
     * Nonce of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    nonce?: string;
    /**
     * Event log index. For transactions that don\'t emit event, create arbitrary index starting from 0
     * @type {number}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    log_index?: number;
    /**
     * Gas limit of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_limit?: string;
    /**
     * Gas used in this transaction. (Optional because not every chain will support this)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_used?: string;
    /**
     * Gas price of the transaction that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    gas_price?: string;
    /**
     * The protocol this transaction belongs to
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    protocol?: string;
    /**
     * Account that emitted this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    account?: string;
    /**
     * The user position changed by this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    position?: string;
    /**
     * lower tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_lower?: string;
    /**
     * upper tick of position
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    tick_upper?: string;
    /**
     * The pool involving this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    pool?: string;
    /**
     * Timestamp of this event
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    timestamp?: string;
    /**
     * Amount of liquidity burned
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    liquidity?: string;
    /**
     * Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_tokens?: Array<string>;
    /**
     * Amount of input tokens in the token\'s native unit
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    input_token_amounts?: Array<string>;
    /**
     * Amount of input tokens in the liquidity pool
     * @type {Array<string>}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    reserve_amounts?: Array<string>;
    /**
     * USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool)
     * @type {string}
     * @memberof UNISWAPV3ETHEREUMWithdrawDTO
     */
    amount_usd?: string;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD. Because there is no guaranteed common base token across pairs, a global reference of USD price is useful for deriving other USD values. The Bundle entity stores an updated weighted average of ETH<->Stablecoin pair prices. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV2BundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BundleDTO
     */
    block_number?: number;
    /**
     * Constant 1.
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    id?: string;
    /**
     * Derived price of ETH in USD based on stablecoin pairs.
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BundleDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2BundleDTO
     */
    block_range?: string;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV2BurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BurnDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction burn array
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UniswapV2BurnDTO
     */
    needs_complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BurnDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more.
 * @export
 */
export type UniswapV2LiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    block_number?: number;
    /**
     * User address and pair address concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    id?: string;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type UniswapV2LiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pair address)-(user address)
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Number of block in which LP snapshot was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotDTO
     */
    block_range?: string;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type UniswapV2MintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2MintDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction mint array.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2MintDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2MintDTO
     */
    block_range?: string;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV2PairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    vid?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    id?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2PairDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Timestamp contract was created.
     * @type {Date}
     * @memberof UniswapV2PairDTO
     */
    created_at_timestamp?: Date;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof UniswapV2PairDTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type UniswapV2PairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    _date?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    pair_address?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataDTO
     */
    daily_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type UniswapV2PairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    hour_start_unix?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataDTO
     */
    hourly_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV2SwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    vid?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {Date}
     * @memberof UniswapV2SwapDTO
     */
    timestamp?: Date;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    sender?: string;
    /**
     * The EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    from?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    to?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2SwapDTO
     */
    log_index?: NumericsBigInteger;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV2SwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapDTO
     */
    transaction_id?: string;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV2TokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV2TokenDTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenDTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    trade_volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    trade_volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    total_liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    derived_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2TokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV2TokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    block_number?: number;
    /**
     * Token address and day id (day start timestamp in unix / 86400) concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_token?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    daily_txns?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_token?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    total_liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type UniswapV2TransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof UniswapV2TransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV2TransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TransactionDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type UniswapV2UniswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    daily_volume_untracked?: string;
    /**
     * All time volume across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_volume_eth?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_liquidity_eth?: string;
    /**
     * All time volume across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_volume_usd?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    total_liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UniswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV2UniswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Uniswap factory.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    pair_count?: number;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    total_liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    tx_count?: string;
    /**
     * .
     * @type {number}
     * @memberof UniswapV2UniswapFactoryDTO
     */
    vid?: number;
}

/**
 * A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity can be used to track open positions for users.
 * @export
 */
export type UniswapV2UserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof UniswapV2UserDTO
     */
    id?: string;
    /**
     * Total USD value swapped.
     * @type {string}
     * @memberof UniswapV2UserDTO
     */
    usd_swapped?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UserDTO
     */
    vid?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV3BundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BundleDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3BundleDTO
     */
    id?: string;
    /**
     * Price of ETH in usd.
     * @type {string}
     * @memberof UniswapV3BundleDTO
     */
    eth_price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV3BurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BurnDTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    id?: string;
    /**
     * Transaction burn was included in.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    transaction?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    token_1?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    timestamp?: string;
    /**
     * Owner of position where liquidity was burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    owner?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    origin?: string;
    /**
     * Amount of liquidity burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount?: string;
    /**
     * Amount of token 0 burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 burned.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    amount_usd?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    tick_upper?: string;
    /**
     * Position within the transactions.
     * @type {string}
     * @memberof UniswapV3BurnDTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BurnDTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV3FactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3FactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    id?: string;
    /**
     * Amount of pools created.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    pool_count?: string;
    /**
     * Amount of transactions all time.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    tx_count?: string;
    /**
     * Total volume all time in derived USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_volume_usd?: string;
    /**
     * Total volume all time in derived ETH.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_volume_eth?: string;
    /**
     * Total swap fees all time in USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_fees_usd?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_fees_eth?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total value locked derived in USD.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived in ETH.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Total value locked derived in ETH untracked.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    total_value_locked_eth_untracked?: string;
    /**
     * Current owner of the factory.
     * @type {string}
     * @memberof UniswapV3FactoryDTO
     */
    owner?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3FactoryDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
 * @export
 */
export type UniswapV3MintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3MintDTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    id?: string;
    /**
     * Which txn the mint was included in.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    transaction?: string;
    /**
     * Time of transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    timestamp?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    token_1?: string;
    /**
     * Owner of position where liquidity minted to.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    owner?: string;
    /**
     * The address that minted the liquidity.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    sender?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    origin?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount?: string;
    /**
     * Amount of token 0 minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 minted.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    amount_usd?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    tick_upper?: string;
    /**
     * Order within the transaction.
     * @type {string}
     * @memberof UniswapV3MintDTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3MintDTO
     */
    vid?: number;
}

/**
 * Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV3PoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    vid?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    id?: string;
    /**
     * Creation time.
     * @type {Date}
     * @memberof UniswapV3PoolDTO
     */
    created_at_timestamp?: Date;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_1?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_tier?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    liquidity?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    sqrt_price?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_growth_global_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    fee_growth_global_1x128?: NumericsBigInteger;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    token_1_price?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    observation_index?: NumericsBigInteger;
    /**
     * All time token0 swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_token_0?: string;
    /**
     * All time token1 swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_token_1?: string;
    /**
     * All time USD swapped.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    volume_usd?: string;
    /**
     * All time USD swapped, unfiltered for unreliable USD pools.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * All time fees collected token0.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time fees collected token1.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_token_1?: string;
    /**
     * All time fees collected derived USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    collected_fees_usd?: string;
    /**
     * Total token 0 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_token_0?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_token_1?: string;
    /**
     * Total token 1 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked USD.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived ETH.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Liquidity providers count, used to detect new exchanges.
     * @type {string}
     * @memberof UniswapV3PoolDTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDTO
     */
    evaluated_ask?: number;
}

/**
 * Data accumulated and condensed into day stats for each pool.
 * @export
 */
export type UniswapV3PoolDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(day id).
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDayDataDTO
     */
    vid?: number;
}

/**
 * Hourly stats tracker for pool.
 * @export
 */
export type UniswapV3PoolHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(day id)
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    period_start_unix?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolHourDataDTO
     */
    vid?: number;
}

/**
 * Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
 * @export
 */
export type UniswapV3PositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionDTO
     */
    block_number?: number;
    /**
     * NFT token identifier.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    owner?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    token_1?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    tick_upper?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the position was initialized.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionDTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type UniswapV3PositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    block_number?: number;
    /**
     * NFT token identifier, format: (NFT token id)#(block number).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    owner?: string;
    /**
     * Pool the position is within.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    pool?: string;
    /**
     * Position of which the snap was taken of.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    position?: string;
    /**
     * Timestamp of block in which the snap was created.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    timestamp?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the snapshot was initialized.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV3SwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    vid?: number;
    /**
     * Identifier, format: (transaction hash) + # + (index in swaps Transaction array).
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    id?: string;
    /**
     * Pointer to transaction.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of transaction.
     * @type {Date}
     * @memberof UniswapV3SwapDTO
     */
    timestamp?: Date;
    /**
     * Pool swap occured within.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    token_1?: string;
    /**
     * Sender of the swap.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    sender?: string;
    /**
     * Recipient of the swap.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    recipient?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    origin?: string;
    /**
     * Delta of token0 swapped.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_0?: string;
    /**
     * Delta of token1 swapped.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_1?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    sqrt_price_x96?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapDTO
     */
    log_index?: NumericsBigInteger;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV3SwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapDTO
     */
    transaction_id?: string;
}

/**
 * Ticks are the boundaries between discrete areas in price space.
 * @export
 */
export type UniswapV3TickDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDTO
     */
    vid?: number;
    /**
     * Identifier, format: (pool address)#(tick index)
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    id?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    pool_address?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    tick_idx?: NumericsBigInteger;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    pool?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_gross?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_net?: NumericsBigInteger;
    /**
     * Calculated price of token0 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    price_0?: string;
    /**
     * Calculated price of token1 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    price_1?: string;
    /**
     * Lifetime volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_token_0?: string;
    /**
     * Lifetime volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_token_1?: string;
    /**
     * Lifetime volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    volume_usd?: string;
    /**
     * Lifetime volume in untracked USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    fees_usd?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_token_1?: string;
    /**
     * All time collected fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDTO
     */
    collected_fees_usd?: string;
    /**
     * Created time.
     * @type {Date}
     * @memberof UniswapV3TickDTO
     */
    created_at_timestamp?: Date;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    liquidity_provider_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    fee_growth_outside_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickDTO
     */
    fee_growth_outside_1x128?: NumericsBigInteger;
}

/**
 * Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
 * @export
 */
export type UniswapV3TickDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: (pool address)-(tick index)-(timestamp).
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    pool?: string;
    /**
     * Pointer to tick.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    tick?: string;
    /**
     * Total liquidity pool has as tick lower or upper at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    liquidity_gross?: string;
    /**
     * How much liquidity changes when tick crossed at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    liquidity_net?: string;
    /**
     * Hourly volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Hourly volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Hourly volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fees_usd?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fee_growth_outside_0x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataDTO
     */
    fee_growth_outside_1x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDayDataDTO
     */
    vid?: number;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV3TokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV3TokenDTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenDTO
     */
    pool_count?: NumericsBigInteger;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked_usd?: string;
    /**
     * TVL derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Derived price in ETH.
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    derived_eth?: string;
    /**
     * Pools token is in that are white listed for USD pricing.
     * @type {Array<string>}
     * @memberof UniswapV3TokenDTO
     */
    whitelist_pools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    block_number?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    period_start_unix?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataDTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenHourDataDTO
     */
    vid?: number;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenV3DayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    vid?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    _date?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    close?: string;
}

/**
 * 
 * @export
 */
export type UniswapV3TransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TransactionDTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    id?: string;
    /**
     * Timestamp txn was confirmed.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    timestamp?: string;
    /**
     * Gas used during txn execution.
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    gas_used?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TransactionDTO
     */
    gas_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TransactionDTO
     */
    vid?: number;
}

/**
 * Data accumulated and condensed into day stats for all of Uniswap.
 * @export
 */
export type UniswapV3UniswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    vid?: number;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total daily volume in Uniswap derived in terms of USD untracked.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    volume_usd_untracked?: string;
    /**
     * Fees in USD
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Tvl in terms of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataDTO
     */
    tvl_usd?: string;
}



/**
 * CRYPTOPUNKSApi - fetch parameter creator
 * @export
 */
export const CRYPTOPUNKSApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/bids/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collectionDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/collections/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/dataSources/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/items/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketPlaces/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/marketplaceDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cryptopunks/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CRYPTOPUNKSApiType = { 
    cRYPTOPUNKSBidsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSBidDTO>>,

    cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>>,

    cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSCollectionDTO>>,

    cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSDataSourcesDTO>>,

    cRYPTOPUNKSItemsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSItemDTO>>,

    cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>>,

    cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>>,

    cRYPTOPUNKSTradesCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSTradeDTO>>,

    cRYPTOPUNKSUsersCurrent(options?: RequestOptions): Promise<Array<CRYPTOPUNKSUserDTO>>,
}

/**
 * CRYPTOPUNKSApi - factory function to inject configuration 
 * @export
 */
export const CRYPTOPUNKSApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CRYPTOPUNKSApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bids.
         * @summary Bids (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSBidsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSBidDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSBidsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collectionDailySnapshots.
         * @summary CollectionDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets collections.
         * @summary Collections (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSCollectionsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSCollectionDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSCollectionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dataSources.
         * @summary DataSources (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSDataSourcesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSDataSourcesDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSDataSourcesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets items.
         * @summary Items (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSItemsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSItemDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSItemsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketPlaces.
         * @summary MarketPlaces (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketPlacesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketPlaceDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketPlacesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets marketplaceDailySnapshots.
         * @summary MarketplaceDailySnapshots (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSMarketplaceDailySnapshotDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSMarketplaceDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSTradesCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSTradeDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cRYPTOPUNKSUsersCurrent(options?: RequestOptions = {}): Promise<Array<CRYPTOPUNKSUserDTO>> {
            const localVarFetchArgs = CRYPTOPUNKSApiFetchParamCreator(configuration).cRYPTOPUNKSUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CowApi - fetch parameter creator
 * @export
 */
export const CowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        cowOrdersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/orders/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets settlements.
         * @summary Settlements (current)
         * @throws {RequiredError}
         */
        cowSettlementsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/settlements/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cowTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cowTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cowUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CowApiType = { 
    cowOrdersCurrent(options?: RequestOptions): Promise<Array<CowOrderDTO>>,

    cowSettlementsCurrent(options?: RequestOptions): Promise<Array<CowSettlementDTO>>,

    cowTokensCurrent(options?: RequestOptions): Promise<Array<CowTokenDTO>>,

    cowTradesCurrent(options?: RequestOptions): Promise<Array<CowTradeDTO>>,

    cowUsersCurrent(options?: RequestOptions): Promise<Array<CowUserDTO>>,
}

/**
 * CowApi - factory function to inject configuration 
 * @export
 */
export const CowApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CowApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        cowOrdersCurrent(options?: RequestOptions = {}): Promise<Array<CowOrderDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowOrdersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets settlements.
         * @summary Settlements (current)
         * @throws {RequiredError}
         */
        cowSettlementsCurrent(options?: RequestOptions = {}): Promise<Array<CowSettlementDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowSettlementsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        cowTokensCurrent(options?: RequestOptions = {}): Promise<Array<CowTokenDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        cowTradesCurrent(options?: RequestOptions = {}): Promise<Array<CowTradeDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        cowUsersCurrent(options?: RequestOptions = {}): Promise<Array<CowUserDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CurveApi - fetch parameter creator
 * @export
 */
export const CurveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        curveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveAddLiquidityEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/addLiquidityEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAdminFeeChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/adminFeeChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAmplificationCoeffChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/amplificationCoeffChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets coins.
         * @summary Coins (current)
         * @throws {RequiredError}
         */
        curveCoinsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/coins/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (current)
         * @throws {RequiredError}
         */
        curveContractVersionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contractVersions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contracts.
         * @summary Contracts (current)
         * @throws {RequiredError}
         */
        curveContractsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contracts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (current)
         * @throws {RequiredError}
         */
        curveDailyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/dailyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (current)
         * @throws {RequiredError}
         */
        curveExchangesCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/exchanges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveFeeChangeLogsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/feeChangeLogs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (current)
         * @throws {RequiredError}
         */
        curveGaugeDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeDeposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (current)
         * @throws {RequiredError}
         */
        curveGaugeLiquiditiesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeLiquidities/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTotalWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTotalWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTypeWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypeWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (current)
         * @throws {RequiredError}
         */
        curveGaugeTypesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeTypes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightVotesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeightVotes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWeights/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (current)
         * @throws {RequiredError}
         */
        curveGaugeWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugeWithdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges.
         * @summary Gauges (current)
         * @throws {RequiredError}
         */
        curveGaugesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gauges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (current)
         * @throws {RequiredError}
         */
        curveHourlyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/hourlyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        curveLpTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/lpTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        curvePoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (current)
         * @throws {RequiredError}
         */
        curveProposalVotesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposalVotes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposals.
         * @summary Proposals (current)
         * @throws {RequiredError}
         */
        curveProposalsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposals/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityOneEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityOneEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (current)
         * @throws {RequiredError}
         */
        curveSystemStatesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/systemStates/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        curveTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (current)
         * @throws {RequiredError}
         */
        curveTransferOwnershipEventsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/transferOwnershipEvents/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (current)
         * @throws {RequiredError}
         */
        curveUnderlyingCoinsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/underlyingCoins/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (current)
         * @throws {RequiredError}
         */
        curveVotingAppsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/votingApps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (current)
         * @throws {RequiredError}
         */
        curveWeeklyVolumesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/weeklyVolumes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CurveApiType = { 
    curveAccountsCurrent(options?: RequestOptions): Promise<Array<CurveAccountDTO>>,

    curveAddLiquidityEventsCurrent(options?: RequestOptions): Promise<Array<CurveAddLiquidityEventDTO>>,

    curveAdminFeeChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveAdminFeeChangeLogDTO>>,

    curveAmplificationCoeffChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveAmplificationCoeffChangeLogDTO>>,

    curveCoinsCurrent(options?: RequestOptions): Promise<Array<CurveCoinDTO>>,

    curveContractVersionsCurrent(options?: RequestOptions): Promise<Array<CurveContractVersionDTO>>,

    curveContractsCurrent(options?: RequestOptions): Promise<Array<CurveContractDTO>>,

    curveDailyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveDailyVolumeDTO>>,

    curveExchangesCurrent(pool?: string, options?: RequestOptions): Promise<Array<CurveExchangeDTO>>,

    curveFeeChangeLogsCurrent(options?: RequestOptions): Promise<Array<CurveFeeChangeLogDTO>>,

    curveGaugeDepositsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeDepositDTO>>,

    curveGaugeLiquiditiesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeLiquidityDTO>>,

    curveGaugeTotalWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTotalWeightDTO>>,

    curveGaugeTypeWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTypeWeightDTO>>,

    curveGaugeTypesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeTypeDTO>>,

    curveGaugeWeightVotesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWeightVoteDTO>>,

    curveGaugeWeightsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWeightDTO>>,

    curveGaugeWithdrawsCurrent(options?: RequestOptions): Promise<Array<CurveGaugeWithdrawDTO>>,

    curveGaugesCurrent(options?: RequestOptions): Promise<Array<CurveGaugeDTO>>,

    curveHourlyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveHourlyVolumeDTO>>,

    curveLpTokensCurrent(options?: RequestOptions): Promise<Array<CurveLpTokenDTO>>,

    curvePoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<CurvePoolDTO>>,

    curveProposalVotesCurrent(options?: RequestOptions): Promise<Array<CurveProposalVoteDTO>>,

    curveProposalsCurrent(options?: RequestOptions): Promise<Array<CurveProposalDTO>>,

    curveRemoveLiquidityEventsCurrent(options?: RequestOptions): Promise<Array<CurveRemoveLiquidityEventDTO>>,

    curveRemoveLiquidityOneEventsCurrent(options?: RequestOptions): Promise<Array<CurveRemoveLiquidityOneEventDTO>>,

    curveSystemStatesCurrent(options?: RequestOptions): Promise<Array<CurveSystemStateDTO>>,

    curveTokensCurrent(options?: RequestOptions): Promise<Array<CurveTokenDTO>>,

    curveTransferOwnershipEventsCurrent(options?: RequestOptions): Promise<Array<CurveTransferOwnershipEventDTO>>,

    curveUnderlyingCoinsCurrent(options?: RequestOptions): Promise<Array<CurveUnderlyingCoinDTO>>,

    curveVotingAppsCurrent(options?: RequestOptions): Promise<Array<CurveVotingAppDTO>>,

    curveWeeklyVolumesCurrent(options?: RequestOptions): Promise<Array<CurveWeeklyVolumeDTO>>,
}

/**
 * CurveApi - factory function to inject configuration 
 * @export
 */
export const CurveApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CurveApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        curveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAccountDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets addLiquidityEvents.
         * @summary AddLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveAddLiquidityEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAddLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAddLiquidityEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets adminFeeChangeLogs.
         * @summary AdminFeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAdminFeeChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAdminFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAdminFeeChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets amplificationCoeffChangeLogs.
         * @summary AmplificationCoeffChangeLogs (current)
         * @throws {RequiredError}
         */
        curveAmplificationCoeffChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveAmplificationCoeffChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveAmplificationCoeffChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets coins.
         * @summary Coins (current)
         * @throws {RequiredError}
         */
        curveCoinsCurrent(options?: RequestOptions = {}): Promise<Array<CurveCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveCoinsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contractVersions.
         * @summary ContractVersions (current)
         * @throws {RequiredError}
         */
        curveContractVersionsCurrent(options?: RequestOptions = {}): Promise<Array<CurveContractVersionDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveContractVersionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contracts.
         * @summary Contracts (current)
         * @throws {RequiredError}
         */
        curveContractsCurrent(options?: RequestOptions = {}): Promise<Array<CurveContractDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveContractsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dailyVolumes.
         * @summary DailyVolumes (current)
         * @throws {RequiredError}
         */
        curveDailyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveDailyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveDailyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (current)
         * @throws {RequiredError}
         */
        curveExchangesCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<CurveExchangeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveExchangesCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets feeChangeLogs.
         * @summary FeeChangeLogs (current)
         * @throws {RequiredError}
         */
        curveFeeChangeLogsCurrent(options?: RequestOptions = {}): Promise<Array<CurveFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveFeeChangeLogsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeDeposits.
         * @summary GaugeDeposits (current)
         * @throws {RequiredError}
         */
        curveGaugeDepositsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeDepositDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeLiquidities.
         * @summary GaugeLiquidities (current)
         * @throws {RequiredError}
         */
        curveGaugeLiquiditiesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeLiquidityDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeLiquiditiesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTotalWeights.
         * @summary GaugeTotalWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTotalWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTotalWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTotalWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypeWeights.
         * @summary GaugeTypeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeTypeWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTypeWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeTypes.
         * @summary GaugeTypes (current)
         * @throws {RequiredError}
         */
        curveGaugeTypesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeTypesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeightVotes.
         * @summary GaugeWeightVotes (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightVotesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWeightVotesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWeights.
         * @summary GaugeWeights (current)
         * @throws {RequiredError}
         */
        curveGaugeWeightsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWeightsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gaugeWithdraws.
         * @summary GaugeWithdraws (current)
         * @throws {RequiredError}
         */
        curveGaugeWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeWithdrawDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugeWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges.
         * @summary Gauges (current)
         * @throws {RequiredError}
         */
        curveGaugesCurrent(options?: RequestOptions = {}): Promise<Array<CurveGaugeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGaugesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourlyVolumes.
         * @summary HourlyVolumes (current)
         * @throws {RequiredError}
         */
        curveHourlyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveHourlyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveHourlyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets lpTokens.
         * @summary LpTokens (current)
         * @throws {RequiredError}
         */
        curveLpTokensCurrent(options?: RequestOptions = {}): Promise<Array<CurveLpTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveLpTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        curvePoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<CurvePoolDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curvePoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposalVotes.
         * @summary ProposalVotes (current)
         * @throws {RequiredError}
         */
        curveProposalVotesCurrent(options?: RequestOptions = {}): Promise<Array<CurveProposalVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveProposalVotesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposals.
         * @summary Proposals (current)
         * @throws {RequiredError}
         */
        curveProposalsCurrent(options?: RequestOptions = {}): Promise<Array<CurveProposalDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveProposalsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityEvents.
         * @summary RemoveLiquidityEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveRemoveLiquidityEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets removeLiquidityOneEvents.
         * @summary RemoveLiquidityOneEvents (current)
         * @throws {RequiredError}
         */
        curveRemoveLiquidityOneEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityOneEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveRemoveLiquidityOneEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets systemStates.
         * @summary SystemStates (current)
         * @throws {RequiredError}
         */
        curveSystemStatesCurrent(options?: RequestOptions = {}): Promise<Array<CurveSystemStateDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveSystemStatesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        curveTokensCurrent(options?: RequestOptions = {}): Promise<Array<CurveTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transferOwnershipEvents.
         * @summary TransferOwnershipEvents (current)
         * @throws {RequiredError}
         */
        curveTransferOwnershipEventsCurrent(options?: RequestOptions = {}): Promise<Array<CurveTransferOwnershipEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveTransferOwnershipEventsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets underlyingCoins.
         * @summary UnderlyingCoins (current)
         * @throws {RequiredError}
         */
        curveUnderlyingCoinsCurrent(options?: RequestOptions = {}): Promise<Array<CurveUnderlyingCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveUnderlyingCoinsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets votingApps.
         * @summary VotingApps (current)
         * @throws {RequiredError}
         */
        curveVotingAppsCurrent(options?: RequestOptions = {}): Promise<Array<CurveVotingAppDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveVotingAppsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets weeklyVolumes.
         * @summary WeeklyVolumes (current)
         * @throws {RequiredError}
         */
        curveWeeklyVolumesCurrent(options?: RequestOptions = {}): Promise<Array<CurveWeeklyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveWeeklyVolumesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DexApi - fetch parameter creator
 * @export
 */
export const DexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets batches.
         * @summary Batches (current)
         * @throws {RequiredError}
         */
        dexBatchesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/batches/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        dexDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        dexOrdersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/orders/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets prices.
         * @summary Prices (current)
         * @throws {RequiredError}
         */
        dexPricesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/prices/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets solutions.
         * @summary Solutions (current)
         * @throws {RequiredError}
         */
        dexSolutionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/solutions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets stats.
         * @summary Stats (current)
         * @throws {RequiredError}
         */
        dexStatsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/stats/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        dexTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        dexTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        dexUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (current)
         * @throws {RequiredError}
         */
        dexWithdrawRequestsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdrawRequests/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        dexWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DexApiType = { 
    dexBatchesCurrent(options?: RequestOptions): Promise<Array<DexBatchDTO>>,

    dexDepositsCurrent(options?: RequestOptions): Promise<Array<DexDepositDTO>>,

    dexOrdersCurrent(options?: RequestOptions): Promise<Array<DexOrderDTO>>,

    dexPricesCurrent(options?: RequestOptions): Promise<Array<DexPriceDTO>>,

    dexSolutionsCurrent(options?: RequestOptions): Promise<Array<DexSolutionDTO>>,

    dexStatsCurrent(options?: RequestOptions): Promise<Array<DexStatsDTO>>,

    dexTokensCurrent(options?: RequestOptions): Promise<Array<DexTokenDTO>>,

    dexTradesCurrent(options?: RequestOptions): Promise<Array<DexTradeDTO>>,

    dexUsersCurrent(options?: RequestOptions): Promise<Array<DexUserDTO>>,

    dexWithdrawRequestsCurrent(options?: RequestOptions): Promise<Array<DexWithdrawRequestDTO>>,

    dexWithdrawsCurrent(options?: RequestOptions): Promise<Array<DexWithdrawDTO>>,
}

/**
 * DexApi - factory function to inject configuration 
 * @export
 */
export const DexApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DexApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets batches.
         * @summary Batches (current)
         * @throws {RequiredError}
         */
        dexBatchesCurrent(options?: RequestOptions = {}): Promise<Array<DexBatchDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexBatchesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        dexDepositsCurrent(options?: RequestOptions = {}): Promise<Array<DexDepositDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets orders.
         * @summary Orders (current)
         * @throws {RequiredError}
         */
        dexOrdersCurrent(options?: RequestOptions = {}): Promise<Array<DexOrderDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexOrdersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets prices.
         * @summary Prices (current)
         * @throws {RequiredError}
         */
        dexPricesCurrent(options?: RequestOptions = {}): Promise<Array<DexPriceDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexPricesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets solutions.
         * @summary Solutions (current)
         * @throws {RequiredError}
         */
        dexSolutionsCurrent(options?: RequestOptions = {}): Promise<Array<DexSolutionDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexSolutionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets stats.
         * @summary Stats (current)
         * @throws {RequiredError}
         */
        dexStatsCurrent(options?: RequestOptions = {}): Promise<Array<DexStatsDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexStatsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        dexTokensCurrent(options?: RequestOptions = {}): Promise<Array<DexTokenDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current)
         * @throws {RequiredError}
         */
        dexTradesCurrent(options?: RequestOptions = {}): Promise<Array<DexTradeDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        dexUsersCurrent(options?: RequestOptions = {}): Promise<Array<DexUserDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdrawRequests.
         * @summary WithdrawRequests (current)
         * @throws {RequiredError}
         */
        dexWithdrawRequestsCurrent(options?: RequestOptions = {}): Promise<Array<DexWithdrawRequestDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexWithdrawRequestsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        dexWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<DexWithdrawDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'dappName' is not null or undefined
            if (dappName === null || dappName === undefined) {
                throw new RequiredError('dappName','Required parameter dappName was null or undefined when calling metadataDappsDappNameGet.');
            }
            const localVarPath = `/metadata/dapps/{dappName}`
                .replace(`{${"dappName"}}`, encodeURIComponent(String(dappName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/dapps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    metadataChainsGet(options?: RequestOptions): Promise<Response>,

    metadataDappsDappNameGet(dappName: string, options?: RequestOptions): Promise<Response>,

    metadataDappsGet(options?: RequestOptions): Promise<Response>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List all chains.
         * @throws {RequiredError}
         */
        metadataChainsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataChainsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Gets dapp by name.
         * @throws {RequiredError}
         */
        metadataDappsDappNameGet(dappName: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsDappNameGet(dappName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all decentralized applications.
         * @throws {RequiredError}
         */
        metadataDappsGet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).metadataDappsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SushiswapApi - fetch parameter creator
 * @export
 */
export const SushiswapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        sushiswapBundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        sushiswapBurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dayData.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        sushiswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/dayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        sushiswapFactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/factories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourData.
         * @summary HourData (current)
         * @throws {RequiredError}
         */
        sushiswapHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/hourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        sushiswapMintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        sushiswapPairDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        sushiswapPairHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        sushiswapPairsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pairs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sushiswapSwapsCurrent(pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        sushiswapTokenDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokenDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sushiswapTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        sushiswapTransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        sushiswapUsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SushiswapApiType = { 
    sushiswapBundlesCurrent(options?: RequestOptions): Promise<Array<SushiswapBundleDTO>>,

    sushiswapBurnsCurrent(options?: RequestOptions): Promise<Array<SushiswapBurnDTO>>,

    sushiswapDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapDayDataDTO>>,

    sushiswapFactoriesCurrent(options?: RequestOptions): Promise<Array<SushiswapFactoryDTO>>,

    sushiswapHourDataCurrent(options?: RequestOptions): Promise<Array<SushiswapHourDataDTO>>,

    sushiswapLiquidityPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>>,

    sushiswapLiquidityPositionsCurrent(options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionDTO>>,

    sushiswapMintsCurrent(options?: RequestOptions): Promise<Array<SushiswapMintDTO>>,

    sushiswapPairDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapPairDayDataDTO>>,

    sushiswapPairHourDataCurrent(options?: RequestOptions): Promise<Array<SushiswapPairHourDataDTO>>,

    sushiswapPairsCurrent(id?: string, options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapSwapsCurrent(pair?: string, options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapTokenDayDataCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDayDataDTO>>,

    sushiswapTokensCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapTransactionsCurrent(options?: RequestOptions): Promise<Array<SushiswapTransactionDTO>>,

    sushiswapUsersCurrent(options?: RequestOptions): Promise<Array<SushiswapUserDTO>>,
}

/**
 * SushiswapApi - factory function to inject configuration 
 * @export
 */
export const SushiswapApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SushiswapApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        sushiswapBundlesCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapBundleDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapBundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        sushiswapBurnsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapBurnDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapBurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dayData.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        sushiswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        sushiswapFactoriesCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapFactoryDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapFactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourData.
         * @summary HourData (current)
         * @throws {RequiredError}
         */
        sushiswapHourDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapLiquidityPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        sushiswapLiquidityPositionsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapLiquidityPositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        sushiswapMintsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapMintDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapMintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        sushiswapPairDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        sushiswapPairHourDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        sushiswapPairsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapPairsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        sushiswapSwapsCurrent(pair?: string, options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapSwapsCurrent(pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        sushiswapTokenDayDataCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTokenDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        sushiswapTokensCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        sushiswapTransactionsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTransactionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapTransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        sushiswapUsersCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapUserDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapUsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UNISWAPV3ETHEREUMApi - fetch parameter creator
 * @export
 */
export const UNISWAPV3ETHEREUMApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/accounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/activeAccounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/deposits/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/dexAmmProtocols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/financialsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/liquidityPoolAmounts/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/liquidityPoolFees/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/liquidityPoolHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/rewardTokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/tickDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/tickHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/tokenWhiteListSymbols/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/tokenWhiteLists/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/usageMetricsDailySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/usageMetricsHourlySnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswap_v3_ethereum/withdraws/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UNISWAPV3ETHEREUMApiType = { 
    uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>>,

    uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>>,

    uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>>,

    uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>>,

    uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>>,

    uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>>,

    uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>>,

    uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>>,

    uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>>,

    uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTickDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>>,

    uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>>,

    uNISWAPV3ETHEREUMTokensCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>>,

    uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>>,

    uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>>,
}

/**
 * UNISWAPV3ETHEREUMApi - factory function to inject configuration 
 * @export
 */
export const UNISWAPV3ETHEREUMApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UNISWAPV3ETHEREUMApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets activeAccounts.
         * @summary ActiveAccounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMActiveAccountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMActiveAccountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMActiveAccountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDepositsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDepositDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDepositsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets dexAmmProtocols.
         * @summary DexAmmProtocols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMDexAmmProtocolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMDexAmmProtocolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets financialsDailySnapshots.
         * @summary FinancialsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMFinancialsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMFinancialsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolAmounts.
         * @summary LiquidityPoolAmounts (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolAmountDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolAmountsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolFees.
         * @summary LiquidityPoolFees (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolFeeDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolFeesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPoolHourlySnapshots.
         * @summary LiquidityPoolHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMLiquidityPoolHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionSnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMPositionsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMPositionDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMPositionsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets rewardTokens.
         * @summary RewardTokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMRewardTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMRewardTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMRewardTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMSwapDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDailySnapshots.
         * @summary TickDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickHourlySnapshots.
         * @summary TickHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTickHourlySnapshotsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTicksCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTickDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTicksCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteListSymbols.
         * @summary TokenWhiteListSymbols (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListSymbolDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListSymbolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenWhiteLists.
         * @summary TokenWhiteLists (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenWhiteListDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokenWhiteListsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMTokensCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMTokenDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsDailySnapshots.
         * @summary UsageMetricsDailySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsDailySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsDailySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets usageMetricsHourlySnapshots.
         * @summary UsageMetricsHourlySnapshots (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMUsageMetricsHourlySnapshotDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMUsageMetricsHourlySnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (current)
         * @throws {RequiredError}
         */
        uNISWAPV3ETHEREUMWithdrawsCurrent(options?: RequestOptions = {}): Promise<Array<UNISWAPV3ETHEREUMWithdrawDTO>> {
            const localVarFetchArgs = UNISWAPV3ETHEREUMApiFetchParamCreator(configuration).uNISWAPV3ETHEREUMWithdrawsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV2Api - fetch parameter creator
 * @export
 */
export const UniswapV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV2BundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV2BurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV2MintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        uniswapV2PairsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pairs/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV2SwapsCurrent(pair?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = ((pair:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2TokenDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokenDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV2TokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV2TransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapFactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/uniswapFactories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        uniswapV2UsersCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV2ApiType = { 
    uniswapV2BundlesCurrent(options?: RequestOptions): Promise<Array<UniswapV2BundleDTO>>,

    uniswapV2BurnsCurrent(options?: RequestOptions): Promise<Array<UniswapV2BurnDTO>>,

    uniswapV2LiquidityPositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>>,

    uniswapV2LiquidityPositionsCurrent(options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionDTO>>,

    uniswapV2MintsCurrent(options?: RequestOptions): Promise<Array<UniswapV2MintDTO>>,

    uniswapV2PairDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2PairDayDataDTO>>,

    uniswapV2PairHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2PairHourDataDTO>>,

    uniswapV2PairsCurrent(id?: string, options?: RequestOptions): Promise<Array<UniswapV2PairDTO>>,

    uniswapV2SwapsCurrent(pair?: string, options?: RequestOptions): Promise<Array<UniswapV2SwapDTO>>,

    uniswapV2TokenDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2TokenDayDataDTO>>,

    uniswapV2TokensCurrent(options?: RequestOptions): Promise<Array<UniswapV2TokenDTO>>,

    uniswapV2TransactionsCurrent(options?: RequestOptions): Promise<Array<UniswapV2TransactionDTO>>,

    uniswapV2UniswapDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV2UniswapDayDataDTO>>,

    uniswapV2UniswapFactoriesCurrent(options?: RequestOptions): Promise<Array<UniswapV2UniswapFactoryDTO>>,

    uniswapV2UsersCurrent(options?: RequestOptions): Promise<Array<UniswapV2UserDTO>>,
}

/**
 * UniswapV2Api - factory function to inject configuration 
 * @export
 */
export const UniswapV2Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV2ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV2BundlesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2BundleDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2BundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV2BurnsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2BurnDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2BurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositionSnapshots.
         * @summary LiquidityPositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2LiquidityPositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidityPositions.
         * @summary LiquidityPositions (current)
         * @throws {RequiredError}
         */
        uniswapV2LiquidityPositionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2LiquidityPositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV2MintsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2MintDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2MintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairDayData.
         * @summary PairDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2PairDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairHourData.
         * @summary PairHourData (current)
         * @throws {RequiredError}
         */
        uniswapV2PairHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2PairHourDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pairs.
         * @summary Pairs (current)
         * @throws {RequiredError}
         */
        uniswapV2PairsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2PairsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV2SwapsCurrent(pair?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2SwapDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2SwapsCurrent(pair, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenDayData.
         * @summary TokenDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2TokenDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TokenDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV2TokensCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV2TransactionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TransactionDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2TransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UniswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapFactories.
         * @summary UniswapFactories (current)
         * @throws {RequiredError}
         */
        uniswapV2UniswapFactoriesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapFactoryDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UniswapFactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (current)
         * @throws {RequiredError}
         */
        uniswapV2UsersCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2UserDTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2UsersCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV3Api - fetch parameter creator
 * @export
 */
export const UniswapV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3BundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3BurnsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        uniswapV3FactoriesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factories/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3MintsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolsCurrent(id?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (id !== undefined) {
                localVarQueryParameter['id'] = ((id:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionSnapshotsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV3SwapsCurrent(pool?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = ((pool:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TickDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tickDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3TicksCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenHourDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenV3DayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokenV3DayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV3TokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV3TransactionsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/transactions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3UniswapDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/uniswapDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV3ApiType = { 
    uniswapV3BundlesCurrent(options?: RequestOptions): Promise<Array<UniswapV3BundleDTO>>,

    uniswapV3BurnsCurrent(options?: RequestOptions): Promise<Array<UniswapV3BurnDTO>>,

    uniswapV3FactoriesCurrent(options?: RequestOptions): Promise<Array<UniswapV3FactoryDTO>>,

    uniswapV3MintsCurrent(options?: RequestOptions): Promise<Array<UniswapV3MintDTO>>,

    uniswapV3PoolDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataDTO>>,

    uniswapV3PoolHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataDTO>>,

    uniswapV3PoolsCurrent(id?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDTO>>,

    uniswapV3PositionSnapshotsCurrent(options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotDTO>>,

    uniswapV3PositionsCurrent(options?: RequestOptions): Promise<Array<UniswapV3PositionDTO>>,

    uniswapV3SwapsCurrent(pool?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapDTO>>,

    uniswapV3TickDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TickDayDataDTO>>,

    uniswapV3TicksCurrent(options?: RequestOptions): Promise<Array<UniswapV3TickDTO>>,

    uniswapV3TokenHourDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataDTO>>,

    uniswapV3TokenV3DayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    uniswapV3TokensCurrent(options?: RequestOptions): Promise<Array<UniswapV3TokenDTO>>,

    uniswapV3TransactionsCurrent(options?: RequestOptions): Promise<Array<UniswapV3TransactionDTO>>,

    uniswapV3UniswapDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataDTO>>,
}

/**
 * UniswapV3Api - factory function to inject configuration 
 * @export
 */
export const UniswapV3Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV3ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3BundlesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3BundleDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3BundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3BurnsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3BurnDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3BurnsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factories.
         * @summary Factories (current)
         * @throws {RequiredError}
         */
        uniswapV3FactoriesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3FactoriesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3MintsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3MintDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3MintsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolDayData.
         * @summary PoolDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets poolHourData.
         * @summary PoolHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current)
         * @throws {RequiredError}
         */
        uniswapV3PoolsCurrent(id?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PoolsCurrent(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positionSnapshots.
         * @summary PositionSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionSnapshotsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PositionSnapshotsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3PositionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3PositionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3PositionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current)
         * @throws {RequiredError}
         */
        uniswapV3SwapsCurrent(pool?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3SwapsCurrent(pool, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tickDayData.
         * @summary TickDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TickDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TickDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3TicksCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TickDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TicksCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenHourData.
         * @summary TokenHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenHourDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokenHourDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokenV3DayData.
         * @summary TokenV3DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3TokenV3DayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokenV3DayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current)
         * @throws {RequiredError}
         */
        uniswapV3TokensCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TokenDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (current)
         * @throws {RequiredError}
         */
        uniswapV3TransactionsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3TransactionDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3TransactionsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapDayData.
         * @summary UniswapDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3UniswapDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3UniswapDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CRYPTOPUNKSApi: CRYPTOPUNKSApiType,

    CowApi: CowApiType,

    CurveApi: CurveApiType,

    DexApi: DexApiType,

    MetadataApi: MetadataApiType,

    SushiswapApi: SushiswapApiType,

    UNISWAPV3ETHEREUMApi: UNISWAPV3ETHEREUMApiType,

    UniswapV2Api: UniswapV2ApiType,

    UniswapV3Api: UniswapV3ApiType,
 }
